
## 1 引言

对于存在多组建共享状态的复杂业务中，数据流状态管理对项目代码可维护性只管重用，因此对比当下react中几种热门的外部状态管理，供不同场景的使用和学习。

## 2 概述
按照风格划分主要可以分为
1. dispatch的redux流派： react-redux，dva，zustand（可以用于中心化或非中心化的数据流）
  强调应用状态的中心化存储和管理，明确的数据流
2. 响应式流派：mobx，valtio
  强调响应式和自动的状态更新机制
3. 原子状态流派，recoil、jotai
  将状态分解为更小的、可组合的单元，允许直接读写操作和声明式的依赖管理

<img width="1340" alt="image" src="https://github.com/cow-Rong/weekly/assets/31033412/4df23f8d-a0a7-4307-a50e-8941dc6eb3d9">
三种风格实现相同的计数器功能：

https://codesandbox.io/p/sandbox/zustand-valtio-jotai-counters-my6np?file=%2Fsrc%2FZustandCounter.tsx%3A7%2C3

### zustand

基础实现和用法：
https://codesandbox.io/embed/react-module-state-05-11ezv

由于不可变，深层次数据赋值需要借助immer或者ramda等去实现简洁改写操作
https://codesandbox.io/p/sandbox/zustand-normal-immer-optics-ramda-updating-ynn3o?file=%2Fsrc%2FApp.tsx%3A33%2C5

### valtio

我们都知道，react 框架中，`setState` 支持函数式写法：

```typescript
this.setState(state => ({
  ...state,
  isShow: true
}))
```

配合解构语法，写起来仍是如此优雅。那数据稍微复杂些呢？我们就要默默忍受 “糟糕的 Immutable” 了：

```typescript
this.setState(state => {
  const cloneProducts = state.products.slice()
  cloneProducts.push({ text: "shoes" })
  return {
    ...state,
    cloneProducts
  }
})
```

**然而有了 Immer，一切都不一样了：**

```typescript
this.setState(produce(state => (state.isShow = true)))

this.setState(produce(state => state.products.push({ text: "shoes" })))
```

### jotai

atom是一个创建atom config的方法，useAtom是一个使用它的hook

```typescript
const oldObj = { value: 1 }
const newObj = produce(oldObj, draft => (draft.value = 2))
```

通过useAtom可以很方便的在组件之间共享atom状态，对于以组件状态为中心的图形化工具而言是非常合适的选择
但是对于以数据维护为中心的场景而言会不适很合适
例如todos中
https://codesandbox.io/p/sandbox/jotai-todos-ijyxm?file=%2Fsrc%2FApp.tsx%3A102%2C1

## 3 总结
<img width="574" alt="image" src="https://github.com/cow-Rong/weekly/assets/31033412/96f32f7c-0465-440c-8b6d-14deca80abb8">

<img width="685" alt="image" src="https://github.com/cow-Rong/weekly/assets/31033412/ee676e70-1f3c-439c-a618-2922328bc212">

引自https://blog.axlight.com/posts/when-i-use-valtio-and-when-i-use-jotai/
